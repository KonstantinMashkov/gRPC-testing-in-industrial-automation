syntax = "proto3";
option cc_enable_arenas = true;

package elecont;

/**
 * Сервис протокола Elecont.
 * Файл содержит protobuf схему данных для Эликонт-КС версий 2.X.X для обеспечения информационного обмена со сторонними программными решениями.
 * Дата: 25.09.2025
  * (C) 2025 АО "ЭЛАРА". Все права защищены.
 * 
 * АО "ЭЛАРА" предоставляет данный файл как открытый элемент программного продукта Эликонт-КС.
 * Внесение изменений в данный файл может нарушить работоспособность производного кода и связанных с ним пользовательских решений.
 * АО "ЭЛАРА" не несёт ответственность за программный код, созданный сторонними разработчиками для обеспечения информационного обмена с Эликонт-КС и использующий данный файл.
 *
 * Лицензирование:
 * Откройте раздел "Лицензия" в документации к продукту для получения подробной информации.
 *
 */
service Elecont {

  /**
  * Получить состояние сервиса.
  */
  rpc GetState (Empty) returns (State) {}
  
  /**
  * Получить пул сигналов по заданным идентификаторам. Если сигналов с заданными идентификаторами не окажется, то вернётся пустой пул.
  * Целочисленные идентификаторы сигналов можно получить, например, вызвав GetAllSignals или GetAllObjectsData
  */
  rpc GetSignalsById (SignalsId) returns (SignalPool) {}
  
  /**
  * Получить пул сигналов по заданным GUID сигналов. Если сигналов с заданными GUID не окажется, то вернётся пустой пул.
  * GUID сигналов можно получить, например, вызвав GetAllSignals или GetAllObjectsData
  */
  rpc GetSignalsByGuid (SignalsGuid) returns (SignalPool) {}
  
  /**
  * Получить пул сигналов по заданному типу сигналов. Если сигналов с заданным типом не окажется, то вернётся пустой пул.
  * Типы сигналов заданы в определении ElecontSignalType в соответствующем перечислении
  */  
  rpc GetSignalsByType (ElecontSignalType) returns (SignalPool) {}
  
  /**
  * Получить пул команд по заданным идентификаторам. Если команд с заданными идентификаторами не окажется, то вернётся пустой пул.
  * Целочисленные идентификаторы команд можно получить, например, вызвав GetAllCommands или GetAllObjectsData
  */  
  rpc GetCommandsById (SignalsId) returns (CommandPool) {}
  
  /**
  * Получить пул команд по заданным GUID команд. Если команд с заданными GUID не окажется, то вернётся пустой пул.
  * GUID команд можно получить, например, вызвав GetAllCommands или GetAllObjectsData
  */  
  rpc GetCommandsByGuid (SignalsGuid) returns (CommandPool) {}
  
  /**
  * Получить пул команд по заданному типу команд. Если команд с заданным типом не окажется, то вернётся пустой пул.
  * Типы команд заданы в определении в ElecontSignalType в соответствующем перечислении
  */  
  rpc GetCommandsByType (ElecontSignalType) returns (CommandPool) {}
  
  /**
  * Создать пустой отчёт (подписку) с заданным идентификатором.
  * По указанному идентификатору в дальнйшем можно оперировать с отчётом. Например, получить сигналы, входящие в данный отчёт
  */ 
  rpc CreateEmptyReport (ReportId) returns (Result) {}
  
  /**
  * Удалить отчёт с заданным идентификатором
  */ 
  rpc DeleteReport (ReportId) returns (Result) {}

  /**
  * Удалить все существующие отчёты (подписки)
  */ 
  rpc DeleteAllReport (Empty) returns (Result) {}
  
  /**
  * Добавить сигналы в отчёт (подписку).
  * В запросе внутри сообщения Report, помимо идентификаторов сигналов, требуется указывать идентификатор существующего отчёта. Его нужно предварительно создать функцией CreateEmptyReport
  */   
  rpc AddSignalToReport (Report) returns (Result) {}
  
  /**
  * Получить пул сигналов из отчёта. Если для отчёта не заданы сигналы, то вернётся пустой пул.
  * В запросе требуется указать идентификатор существующего отчёта
  */     
  rpc GetSignalsByReport (ReportId) returns (SignalPool) {}
  
  /**
  * Получить пул изменённых сигналов с момента предыдущего вызова данной функции. Если ни один сигнал не менял значение, то вернётся пустой пул.
  * Данную функцию нельзя использовать совместно с GetAllSignals
  */  
  rpc GetChangedSignals (Empty) returns (SignalPool) {}
  
  /**
  * Получить пул изменённых сигналов с момента предыдущего вызова данной функции из заданного отчёта. Если ни один сигнал не менял значение, то вернётся пустой пул.
  *
  * [ВНИМАНИЕ]: На текущий момент работает аналогично GetSignalsByReport. Не рекомендуется для использования сторонними приложениями на текущем этапе
  */    
  rpc GetChangedSignalsByReport (ReportId) returns (SignalPool) {}
  
  /**
  * Получить пул всех сигналов из текущей конфигурации КС. 
  * Для больших конфигураций с большим количеством сигналов этот вызов может быть ресурсоёмким, поэтому его рекомендуется его использовать с осторожностью
  */  
  rpc GetAllSignals (Empty) returns (SignalPool) {}
  
  /**
  * Получить пул всех команд из текущей конфигурации КС. 
  * Для больших конфигураций с большим количеством команд этот вызов может быть ресурсоёмким, поэтому его рекомендуется его использовать с осторожностью
  */  
  rpc GetAllCommands (Empty) returns (CommandPool) {}
  
  /**
  * Задать значения сигналов в КС из заданного пула. Значения будут установленты только тем сигналам, идентификаторы которых существуют в текущей конфигурации КС
  */     
  rpc SetSignals (SignalPool) returns (Result) {}
  
  /**
  * Получить все сигналы из текущей конфигурации КС в виде потока. 
  * Обратите внимание, что внутри потока передаются сообщения Signal. Это облегчённая версия представления данных по отношению к SignalPool
  */    
  rpc GetSignalsStream (Empty) returns (stream Signals) {}
  
  /**
  * Получить все команды из текущей конфигурации КС в виде потока. 
  * Обратите внимание, что внутри потока передаются сообщения Command. Это облегчённая версия представления данных по отношению к CommandPool
  */ 
  rpc GetCommandsStream (Empty) returns (stream Commands) {}
  
  /**
  * Получить данные всех объектов из текущей конфигурации КС. 
  * Данный вызов имеет смысл производить только один раз, так как данные текущей конфигурации КС не изменяются до тех пор, пока её не обновять через api gateway. Например, это сделает пользователь через Конфигуратор
  */ 
  rpc GetAllObjectsData (Empty) returns (Objects) {}
  
  /**
  * Получить сигнал по заданному GUID. Если сигнала с заданными GUID не окажется в текущей конфигурации КС, то вернётся сообщение Signal с данными по умолчанию.
  * Является обегчённой версией функции GetSignalsByGuid. Возвращает простое по структуре сообщение Signal
  */
  rpc GetSignalByGuid (Guid) returns (Signal) {}
  
  /**
  * Получить команду по заданному GUID. Если сигнала с заданными GUID не окажется в текущей конфигурации КС, то вернётся сообщение Command с данными по умолчанию.
  * Является обегчённой версией функции GetCommandsByGuid. Возвращает простое по структуре сообщение Command
  */  
  rpc GetCommandByGuid (Guid) returns (Command) {}
  
  /**
  * Задать сигнал. Запрос должен содержать сообщение Signal с GUID, который существует в текущей конфигурации КС. Если сигнал с таким GUID не будет обраружен, то запрос выполнен не будет.
  * Является обегчённой версией функции SetSignals. Принимает в качестве запроса простое по структуре сообщение Signal
  */  
  rpc SetSignal (Signal) returns (Result) {}
  
  /**
  * Задать команду. Запрос должен содержать сообщение Command с GUID, который существует в текущей конфигурации КС. Если команда с таким GUID не будет обраружена, то запрос выполнен не будет
  */  
  rpc SetCommand (Command) returns (Result) {}
  
  /**
  * Задать сигналы клиентским потоком. 
  * Сообщения Signal в потоке должны содержать GUID, которые существует в текущей конфигурации КС. Если GUID какого-либо сигнала не будет обраружен, то для этого GUID данные сигнала заданы не будут.
  *
  * [ВНИМАНИЕ]: Функция не оттестирована. Не рекомендуется для использования сторонними приложениями на текущем этапе
  */
  rpc SetSignalsStream (stream Signals) returns (Empty) {}
  
  /**
  * Задать команды клиентским потоком. 
  * Сообщения Command в потоке должны содержать GUID, которые существует в текущей конфигурации КС. Если GUID какой-либо команды не будет обраружен, то для этого GUID данные команды заданы не будут.
  *
  * [ВНИМАНИЕ]: Функция на текущий не работает и находится в разработке. Рассматривается целесообразность её реализации. Не рекомендуется для использования сторонними приложениями на текущем этапе
  */  
  rpc SetCommandsStream (stream Commands) returns (Empty) {}
}

/*
 * Определение пустого сообщения
 */
message Empty {}

/*
 * Сообщение, определяющее идентификатор отчёта. В привычных терминах это можно назвать идентификатором подписки
 */
message ReportId{
  int32 id = 1;					// Целочисленный идентификатор отчёта
}

/*
 * Сообщение, определяющее список целочисленных идентификаторов сигналов
 */
message SignalsId {
  repeated int32 id = 1;		// Список идентификаторов
}

/*
 * Сообщение, определяющее GUID объекта. 
 */
message Guid {
  string guid = 1; 				// Строковое представление GUID в формате с дефисами: 01234567-89ab-cdef-0123-456789abcdef
}

/*
 * Сообщение, определяющее список GUID сигналов
 */
message SignalsGuid {
  repeated string guid = 1; 	// Список GUID
}

/*
 * Сообщение, определяющее отчёт (подписку)
 */
message Report{
  ReportId id = 1;				// Идентификатор отчёта
  SignalsId sig_ids = 2;		// Целочисленные идентификаторы сигналов, входящие в отчёт
  SignalsGuid sig_guids = 3;	// GUID сигналов, входящие в отчёт
}

/*
 * Сообщение, определяющее результат выполнения какого-либо операции
 */
message Result {
  enum Value {
    SUCCESS = 0;	// Успех
	FAIL = 1;		// Провал
  }
  Value value = 1;
}

/*
 * Сообщение, определяющее состояние сервиса
 */
message State {
  enum Value {
    INIT = 0;			// Инициализация
	READY = 1;			// Готов
	BUSY = 2;			// Занят
	CRITICAL_ERROR = 3;	// Критическая ошибка
  }
  Value value = 1;
}

/*
 * Сообщение, определяющее тип значения сигнала. Это сообщение применимо и для команд
 */
message ElecontSignalType {
  enum Value {
	BOOLEAN = 0;				// Логический
	INT8 = 1;					// Целочисленный 8 бит
	INT16 = 2;					// Целочисленный 16 бит
	INT32 = 3;					// Целочисленный 32 бит
  	INT64 = 4;					// Целочисленный 64 бит
	INT128 = 5;					// Целочисленный 128 бит
	INT8U = 6;					// Целочисленный беззнаковый 8 бит
	INT16U = 7;					// Целочисленный беззнаковый 16 бит
	INT32U = 8;					// Целочисленный беззнаковый 32 бит
	INT64U = 9;					// Целочисленный беззнаковый 64 бит
	FLOAT32 = 10;				// Действительный (вещественный) 32 бит
	FLOAT64 = 11;				// Действительный (вещественный) 64 бит
	ENUMERATED = 12;			// Перечисление
	CODED_ENUM = 13;			// Кодированное перечисление. Элементы этого перечисления имеют строковое значение, которое используется в качестве кода или идентификатора
	OCTET_STRING_6 = 14;		// Строка из 6 последовательных байт (октетов)
	OCTET_STRING_8 = 15;		// Строка из 8 последовательных байт (октетов)
	OCTET_STRING_64 = 16;		// Строка 64 последовательных байт (октетов)
	VISIBLE_STRING_32 = 17;		// Строка из 32 символов
	VISIBLE_STRING_64 = 18;		// Строка из 64 символов
	VISIBLE_STRING_65 = 19;		// Строка из 65 символов
	VISIBLE_STRING_255 = 20;	// Строка из 255 символов
	UNICODE_STRING = 21;		// Unicode строка
	BITFIELD_2 = 22;			// Битовое поле из двух элементов
	BITFIELD_13 = 23;			// Битовое поле из тринадцати элементов
	BITFIELD_32 = 24;			// Битовое поле из тридцати двух элементов
	UNKNOWN = 25;				// Неизвестный
  }
  Value value = 1;
}

/*
 * Сообщение, определяющее состояние команды. 
 */
message CommandState {
  enum Value {
    REQUEST = 0;				// Запрос на выполнение
	POSITIVE_RESPONSE = 1;		// Положительная реакция
	NEGATIVE_RESPONSE = 2;		// Отрицательная реакция
	COMPLETE = 3;				// Выполнена
	TIMEOUT = 4;				// Время на выполнение истекло
  }
  Value value = 1;
}

/*
 * Сообщение, определяющее операцию, выполняемую командой. 
 */
message CommandService {
  enum Value {
    SELECT = 0;					// Выбор
	SELECT_WITH_VAL = 1;		// Выбор со значением
	CANCEL = 2;					// Отмена
	OPERATE = 3;				// Воздействие
    TERMINATION = 4;			// Прерывание
	TIMED_OPERATE = 5;			// Воздействие, ограниченное по времени
	UNDEFINED = 6;				// Не определена
	}
  Value value = 1;
}

/*
 * @brief SignalProperties
 * Сообщение, определяющее свойства сигнала. 
 */
message SignalProperties {
    int32 id = 1;				// Целочисленный идентификатор для оперирования объектом в ядре КС 
    int64 quality = 2;			// Приведённое качество
	int32 raw_quality = 3;		// Сырое качество
	int32 source_id = 4;		// Идентификатор источника
    fixed64 time = 5;			// Метка времени
    string guid = 6;			// Строковой guid для идентификации объекта в конфигурации
    string str_quality = 7;		// Качество сигнала в виде понятного описания
}

/*
 * Сообщение, определяющее сигнал типа: boolean. 
 */
message BooleanSignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bool value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: int8.
 */
message Int8Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  int32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: int16.
 */
message Int16Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  int32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: int32.
 */
message Int32Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  int32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: int64.
 */
message Int64Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  int64 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: int128
 */
message Int128Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  int64 value_high = 2;			// Верхняя часть значения сигнала
  int64 value_low = 3;			// Нижняя часть значения сигнала
}

/*
 * Сообщение, определяющее сигнал типа: uint8
 */
message Int8USignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  uint32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: uint16
 */
message Int16USignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  uint32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: uint32
 */
message Int32USignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  uint32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: uint64
 */
message Int64USignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  uint64 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: float32
 */
message Float32Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  float value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: float64
 */
message Float64Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  double value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: перечисление
 */
message EnumeratedSignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  int32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: кодированное перечисление
 */
message CodedEnumSignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  int32 value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: 6 последовательных байт (октетов)
 */
message OctetString6Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bytes value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: 8 последовательных байт (октетов)
 */
message OctetString8Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bytes value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: 64 последовательных байт (октетов)
 */
message OctetString64Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bytes value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: строка из 32 символов
 */
message VisibleString32Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  string value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: строка из 64 символов
 */
message VisibleString64Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  string value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: строка из 65 символов
 */
message VisibleString65Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  string value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: строка из 255 символов
 */
message VisibleString255Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  string value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: Unicode строка
 */
message UnicodeStringSignal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bytes value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: битовая строка (последовательность из 1 и 0) из двух элементов
 */
message BitString2Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bytes value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: битовая строка (последовательность из 1 и 0) из тринадцати элементов
 */
message BitString13Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bytes value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее сигнал типа: битовая строка (последовательность из 1 и 0) из тридцати двух элементов
 */
message BitString32Signal {
  SignalProperties sigprop = 1;	// Свойства сигнала
  bytes value = 2;				// Значение сигнала
}

/*
 * Сообщение, определяющее пул сигналов. Универсальное хранилище, содержащее списки всех типов сигналов
 */
message SignalPool {
  repeated bool undefined_signal = 1;								// Признек неопределённости
  repeated BooleanSignal boolean_signal = 2;						// Список сигналов типа: boolean
  repeated Int8Signal int8_signal = 3;								// Список сигналов типа: int8
  repeated Int16Signal int16_signal = 4;							// Список сигналов типа: int16
  repeated Int32Signal int32_signal = 5;							// Список сигналов типа: int32
  repeated Int128Signal int128_signal = 6;							// Список сигналов типа: int128
  repeated Int8USignal int8u_signal = 7;							// Список сигналов типа: uint8
  repeated Int16USignal int16u_signal = 8;							// Список сигналов типа: uint16
  repeated Int32USignal int32u_signal = 9;							// Список сигналов типа: uint32
  repeated Float32Signal float32_signal = 10;						// Список сигналов типа: float32
  repeated Float64Signal float64_signal = 11;						// Список сигналов типа: float64
  repeated EnumeratedSignal enumerated_signal = 12;					// Список сигналов типа: перечисление
  repeated CodedEnumSignal coded_enum_signal = 13;					// Список сигналов типа: кодированное перечисление

  repeated OctetString6Signal octet_string6_signal = 14;			// Список сигналов типа: 6 последовательных байт (октетов)
  repeated OctetString8Signal octet_string8_signal = 15;			// Список сигналов типа: 8 последовательных байт (октетов)
  repeated OctetString64Signal octet_string64_signal = 16;			// Список сигналов типа: 64 последовательных байт (октетов)

  repeated VisibleString32Signal visible_string32_signal = 17;		// Список сигналов типа: строка из 32 символов
  repeated VisibleString64Signal visible_string64_signal = 18;		// Список сигналов типа: строка из 64 символов
  repeated VisibleString65Signal visible_string65_signal = 19;		// Список сигналов типа: строка из 65 символов
  repeated VisibleString255Signal visible_string255_signal = 20;	// Список сигналов типа: строка из 255 символов

  repeated UnicodeStringSignal unicode_string_signal = 21;			// Список сигналов типа: Unicode строка
  repeated BitString2Signal bit_string2_signal = 22;				// Список сигналов типа: битовая строка (последовательность из 1 и 0) из двух элементов
  repeated BitString13Signal bit_string13_signal = 23;				// Список сигналов типа: битовая строка (последовательность из 1 и 0) из тринадцати элементов
  repeated BitString32Signal bit_string32_signal = 24;				// Список сигналов типа: битовая строка (последовательность из 1 и 0) из тридцати двух элементов
  
  repeated Int64USignal int64u_signal = 25;							// Список сигналов типа uint64
  repeated Int64Signal int64_signal = 26;							// Список сигналов типа int64
}

/*
 * Сообщение, определяющее свойства команды
 */
message CommandProperties {
    int32 id = 1;					// Целочисленный идентификатор для оперирования объектом в ядре КС 
    fixed64 time = 2;				// Метка времени
    string guid = 3;				// Строковой guid для идентификации объекта в конфигурации
    CommandState state = 4;			// Состояние команды
    CommandService service = 5;		// Выполняемая операция
    int32 source_id = 6;			// Идентификатор источника
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: boolean
 */
message BooleanCommand {
  CommandProperties cmdprop = 1;	// Свойства команды
  bool value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: двухэлементный bitfield
 */
message Bitfield2Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  bytes value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: int8
 */
message Int8Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  int32 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: uint8
 */
message Int8UCommand {
  CommandProperties cmdprop = 1;	// Свойства команды
  uint32 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: int16
 */
message Int16Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  int32 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: uint16
 */
message Int16UCommand {
  CommandProperties cmdprop = 1;	// Свойства команды
  uint32 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: int32
 */
message Int32Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  int32 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: uint8
 */
message Int32UCommand {
  CommandProperties cmdprop = 1;	// Свойства команды
  uint32 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: int64
 */
message Int64Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  int64 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: uint64
 */
message Int64UCommand {
  CommandProperties cmdprop = 1;	// Свойства команды
  uint64 value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: float32
 */
message Float32Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  float value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: float64
 */
message Float64Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  double value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее команду с передаваемым значением типа: строка из 255 символов
 */
message VisibleString255Command {
  CommandProperties cmdprop = 1;	// Свойства команды
  string value = 2;					// Передаваемое значение
}

/*
 * Сообщение, определяющее пул команд. Универсальное хранилище, содержащее массивы для всех типов команд. 
 */
message CommandPool {
  repeated BooleanCommand boolean_command = 1;						// Список команд с передаваемым значением типа: boolean
  repeated Bitfield2Command bitfield2_command = 2;					// Список команд с передаваемым значением типа: двухэлементный bitfield
  repeated Int8Command int8_command = 3;							// Список команд с передаваемым значением типа: int8
  repeated Int8UCommand int8u_command = 4;							// Список команд с передаваемым значением типа: uint8
  repeated Int16Command int16_command = 5;							// Список команд с передаваемым значением типа: int16
  repeated Int16UCommand int16u_command = 6;						// Список команд с передаваемым значением типа: uint16
  repeated Int32Command int32_command = 7;							// Список команд с передаваемым значением типа: int32
  repeated Int32UCommand int32u_command = 8;						// Список команд с передаваемым значением типа: uint32
  repeated Int64Command int64_command = 9;							// Список команд с передаваемым значением типа: int64
  repeated Int64UCommand int64u_command = 10;						// Список команд с передаваемым значением типа: uint64
  repeated Float32Command float32_command = 11;						// Список команд с передаваемым значением типа: float32
  repeated Float64Command float64_command = 12;						// Список команд с передаваемым значением типа: float64
  repeated VisibleString255Command visible_string255_command = 13;	// Список команд с передаваемым значением типа: строка из 255 символов
}

/*
 * Сообщение, определяющее список сигналов. Облегчённое представление пула
 */
message Signals {
  repeated Signal signal = 1;	// Список сигналов
}

/*
 * Сообщение, определяющее список команд. Облегчённое представление пула
 */
message Commands {
  repeated Command command = 1;	// Список команд
}

/*
 * Сообщение, определяющее сигнал. Облегчённое представление. Используется в потоке
 */
message Signal {
  string guid = 1;				// Строковой guid для идентификации объекта в конфигурации
  int64 quality = 2;			// Целочисленное представление качества
  fixed64 time = 3;				// Метка времени
  ElecontSignalType type = 4;	// Тип значения
  string value = 5;				// Значение сигнала
  string str_quality = 6;		// Качество сигнала в виде понятного описания
}

/*
 * Сообщение, определяющее команду. Облегчённое представление. Используется в потоке.
 */
message Command {
  string guid = 1;				// Строковой guid для идентификации объекта в конфигурации
  fixed64 time = 2;				// Метка времени
  ElecontSignalType type = 3;	// Тип значения
  string value = 4;				// Строковое представление значения
  CommandState state = 5;		// Состояние команды
  CommandService service = 6;	// Выполняемая операция
  int32 source_id = 7;			// Идентификатор источника
}

/*
 * Сообщение, определяющее семейство объекта коммуникационного сервера.
 */
message ObjectFamily {
  enum Value {
    RX_SIGNAL  = 0;				// Принимаемый сигнал
	TX_SIGNAL  = 1;				// Передаваемый сигнал
	RX_COMMAND = 2;				// Принимаемая команда
	TX_COMMAND = 3;				// Передаваемая команда
  }
  Value value = 1;
}

/*
 * Сообщение с данными объекта коммуникационного сервера.
 */
message ObjectData {
  ObjectFamily family = 1;		// Семейство объекта
  ElecontSignalType type = 2;	// Тип значения
  string guid = 3;				// Строковой guid для идентификации объекта в конфигурации
  string userdata = 4;			// Пользовательские данные
}

/*
 * Сообщение - список объектов коммуникационного сервера.
 */
message Objects {
  repeated ObjectData data = 1;	// Список данных объектов
}
